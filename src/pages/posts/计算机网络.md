---
author: pigstar
cover:
  alt: cover
  square: https://cdn.jsdelivr.net/gh/pigstar02/blog_img//202308070938013.jpeg
  url: https://cdn.jsdelivr.net/gh/pigstar02/blog_img//202308070938013.jpeg
description: ''
keywords: 面试, 计算机网络 
layout: ../../layouts/MarkdownPost.astro
meta:
- content: pigstar
  name: author
- content: 面试, 计算机网络 
  name: keywords
pubDate: 2023-08-07 10:43:00
tags:
- 面试
- 计算机网络
theme: light
title: 计算机网络
---

## OSI的7层网络模型？
分为应用层、表示层、会话层、运输层、网络层、链路层、物理层。(All people seem to need data processing)

- 应用层：最上层，确定进程之间通信的性质以及满足用户需要以及提供网络和用户应用，为应用程序提供服务。比如dns，pop3，smtp，http。
- 表示层：主要是负责数据的编码解码问题，保证数据能在不同的系统间传输。如数据转换，压缩和加密，解密。
- 会话层：会话层就是管理各个实体之间的会话，会话可以理解成一个请求。比如登陆验证就在登陆会话层。
- 传输层：主要负责数据在不同进程间的传输，包括可靠与不可靠的传输，传输层的错误检测，流量控制，拥塞控制。TCP UDP就在这层。
- 网络层：IP就是这层。总的来说，传输层定义数据以什么形式传输或以怎样的单位传输，通过一些包头检查错误，而网络层则是通过IP地址建立连接，并且选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。
- 数据链路层(帧)：将上层数据封装成帧，用MAC地址访问媒介，并由错误检测和修正。对于网络层，由于链路层的存在，而不需要关心物理层具体采用了那种传输介质和通信设备。
- 物理层(比特流)：就是现实生活中的光缆连接。设备之间比特流的传输，物理接口，电气特性(常用设备有(各种物理设备)集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。)

## TCP如何保证可靠传输
1. 校验和：其中，校验和是一种简单的错误检测方法，它通过将数据段中的每个字节相加，得到一个16位的二进制数，然后取反得到一个16位的二进制数，再将这两个16位的二进制数相加，得到一个新的16位的二进制数。其实本质是一个哈希函数，接收端通过比较哈希值是否一致来确认是否有数据丢失。
2. 序列号/确认应答：tcp把数据分成一个一个包传输，只有确认收到上一个包才会传输下一个包。
3. 超时重传：在发送一个数据段后，TCP会开启一个定时器，如果在一定时间内没有收到对应的ACK报文，则认为该数据段丢失或损坏，需要对数据段进行重传 。如果重传多次仍未成功，TCP会降低当前的数据发送速率，因为TCP会认为当前网络发生了拥塞。
4. 连接管理：三次握手，四次挥手。
5. 流量控制：避免接受方的处理速度跟不上发送方的速度，导致数据溢出丢包。接收方在返回ack时会带上一个接收窗口的大小，然后发送方通过窗口大小动态调整发送速率。
6. 快速重传：不是基于时间而是基于数据的重传机制，当连续收到三个相同的ACK，说明发生了丢包，这个时候要进行重传。但是我们不知道是重传返回的ack的那一个还是它之后的所有。如果是一个的话，如果连续丢了若干个包，那每个包都要三次相同ack触发快速重传；如果把丢包后面全部重传一遍，那会把成功传输的包也重传。所以有一个改良的方式，就是在返回ack的时候带上已接受到的数据的信息。
7. 拥塞控制：
	1. 慢启动算法：一般在传输刚开始的时候网络比较拥堵，一次性发送大量数据可能会造成大量丢包，所以选择慢启动。
	   - 刚开始把发送窗口大小设置为1
	   - 然后每次成功收到ack就加1
	   - 如果一个RTT时间内没有出现丢包重传就把窗口大小乘以2
	   - 如果窗口大小大于等于我们设置的一个阈值，则退出慢启动状态，进入拥塞避免状态
	2. 拥塞避免状态：然后每次成功收到ack就窗口大小加1。一但发现丢包和超时重传，就进入拥塞处理状态。
	3. 拥塞处理状态：
	   - 超时重传：把阈值变成当前窗口大小的一半，把窗口大小重置为1
	   - 快速重传：窗口大小设置为原来的一半，阈值设置和窗口大小一样，然后进入快速恢复状态
	4. 快速恢复状态：
	   - 把窗口大小设置为阈值+3，这里的3就是快速重传的三个相同的ack
	   - 重传丢失的数据包
	   - 一旦收到重复的ack就把窗口大小+1
	   - 收到新的ack说明快速重传结束，把窗口大小设置回原来的阈值大小。

## 三次握手

![三次握手](https://pic.imgdb.cn/item/63e199104757feff33703bd8.jpg)

**第一次握手**

客户端请求建立连接，将首部的SYN标识位置为1，初始化序列号seq=x，发送给服务器，并进入**SYN_SENT**状态，等待服务器确认。

**第二次握手**

服务器接收到SYN后，将首部的SYN和ACK标识位置为1，回复确认ack的值为客户端发送的序列号x+1，同时自己也要初始化一个seq=y，ACK和SYN一起发送客户端，进入**SYN_RECV**状态。

**第三次握手**

客户端收到服务器的SYN和ACK包后，向服务器发送确认包ack，值为服务器的序列号y+1，并且自己的seq为x+1，此包发送完毕，客户端和服务器进入**ESTABLISHED**（TCP连接成功）状态。

## TCP为什么要三次握手
只有三次握手才能证明服务端和客户端的收发能力都是正常的。

第一次握手：客户端发数据服务端接收，服务端可以知道客户端发消息的能力是正常的，自己接收消息的能力是正常的。

第二次握手：服务端发消息客户端收，客户端可以知道自己发送接收消息的能力和服务端发送接收消息的能力是正常的。

第三次握手：客户端再发送消息服务端接收，服务端可以知道自己发送消息的能力是正常的，客户端接收消息的能力是正常的。

由此经过三次握手之后双方就可以都知道自己的发送和接收消息的能力是正常的。

## TCP的三次握手丢了会怎么样？
在TCP通信连接的过程中，ACK报文发生了丢包是不会重传的，ACK 丢失是由对方重传对应的报文。

**第一次丢失**：客户端发送的SYN报文会收不到服务端的响应，从而会触发超时重传，重传的SYN报文序列号和之前相同，重传最大重传次数由内核参数控制，一般是5。如果超过最大次数客户端仍没有收到回复就会断开连接。

**第二次丢失**：服务端在收到客户端的报文之后会回复SYN+ACK报文，如果第二次握手丢失了客户端会认为自己丢包了，触发超时重传，重新发送SYN报文，服务端因为收不到确认的ACK自身也会重传。

**第三次丢失**：客户端收到服务端的 SYN-ACK 报文后会给服务端回一个 ACK 报文，此时客户端状态进入到 ESTABLISH 状态。如果发生了丢包，服务端收不到ACK会触发超时重传机制，重传 SYN-ACK 报文，直到收到确认ACK或者达到最大重传次数。

## 为什么不是两次握手
第一次握手的请求被阻塞在网络中，然后客户端重传第一次握手的请求，最后建立了连接。此时，阻塞的请求到达服务端，服务端无法区分这是一个新请求还是之前失效的请求，所以返回了一个ack，如果此时是两次握手，请求将被重新建立，如果是三次握手的话，客户端收到ack就能判断这是一个失效的连接就不会进行第三次握手，也就不会重新连接。

## 四次挥手
![四次挥手](https://pic.imgdb.cn/item/63e19a374757feff33718597.jpg)
**第一次挥手**

客户端发送释放报文，并停止发送数据，将首部的FIN标识位置为1，序列号seq=u发送给服务器，值等于前面已经传送过来的数据的最后一个字节的序号加1，此时客户端进入FIN_WAIT_1状态。即便FIN报文不携带数据，也要消耗一个序列号。

**第二次挥手**

服务器在收到释放报文后，发送确认报文，ACK标识位置为1，ack值为客户端发送的序列号u+1，并带上自己的序列号v，然后服务器进入CLOSE_WAIT关闭等待状态。这时服务器TCP通知高级应用进程，客户端向服务器的连接释放了，进入半关闭状态，但是服务器如果向客户端发送数据，客户端仍然可以接收，这个状态要持续一段时间，也就是CLOSE_WAIT关闭等待持续的时间。

客户端收到服务器的确认请求后，进入FIN_WAIT_2状态，等待服务器发送释放报文。

**第三次挥手**

服务器数据处理完毕后，向客户端发送释放连接报文，FIN标识位置为1，ack的值为客户端的序列号u+1，由于在半关闭状态，服务器很可能又发送一些数据，假定此时序列号为w，服务器进入LAST_ACK状态，等待客户端确认。

**第四次挥手**

客户端在收到服务器的释放连接报文后，会发送确认报文，ACK标识位置为1，ack值为服务器发送的序列号w+1，

自己的序列号是u+1，然后客户端就进入TIME_WAIT状态。此时TCP连接还没有释放，必须经过两个MSL时间（一个MSL指的是报文段最长寿命），当客户端撤销TCB，才进入CLOSED状态。

服务器只要收到客户端发送的确认请求，立即进入CLOSED状态。同时会撤销TCB，TCP连接至此结束。

**为什么要等待两个报文时段？**
等待服务端收到后返回ack刚好一个来回，如果没有收到就回出发超时重传机制，重置计时器。
还有一个原因是如果第四次挥手后马上断开，如果客户端马上又开启一个连接，恰好端口号又相同，之前阻塞在网络中的旧数据在新连接成功后到达，数据就乱了。所以等待确保老数据都失效。

## TCP的延迟应答和累计应答？
延迟应答：TCP在接收到对端的报文后并不会立即发送ACK，而是等待一段时间发送ACK，以便将ACK和要发送的数据一块发送。延迟时间不能无限延长，否则对方端会认为丢包超时而造成超时重传。

累计应答：为了保证顺序性，每一个包都有一个ID（序号），在建立连接的时候，双方会商定起始的ID是多少，然后按照ID一个个发送。为了保证不丢包，对应发送的包都要进行应答，但不是一个个应答，而是会应答某个之前的ID（可以是下一个期望的ID），该模式称为累计应答。

## 已经建立了连接，客户端突然出现故障了会怎样？
TCP有保活计时器，一般为两个小时，每次响应后都会重置计时器。如果客户端出现故障超过2小时没回应，服务端会每隔75s向客户端发送探测报文，如果连续10个报文没有收到回复，则会认为客户端异常，断开连接。

计时器时间太短会频繁发送探测报文，太长的话会保存很多无效链接，太短太长都会浪费资源，两小时是个合理的值。

## 什么时候用长连接，短连接？
长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。三次握手需要消耗时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，下次处理时直接发送数据包就可以，不用建立TCP连接。例如：数据库的连接用长连接。

WEB网站的HTTP服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而WEB网站成千上万客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话会占用大量资源，所以并发量大，用短链接可以快速释放资源。

所以说，这其实是一个内存资源和时间效率的平衡问题。内存充裕的情况下可以使用长连接来提升响应速度，内存不足的话用短连接可以快速释放资源。

## TCP的半连接队列和全连接队列？掌握
半连接队列：收到第一次握手的请求后，内核会把该连接存储到半连接队列，并向客户端进行第二次握手。

全连接队列：也称 accept 队列，服务端收到第三次握手的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到全连接队列，等待进程调用 accept 函数时把连接取出来。

## 什么是SYN攻击？
SYN攻击是指利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。如果向某个服务器端口发送大量的SYN报文，接收到客户端发来的SYN报文之后，服务端就需要为每个请求分配一个进程控制块TCB，并返回一个SYN-ACK报文，并立即转为SYN_RECV半开连接状态，收不到对端ACK回复的服务端还会重传SYN-ACK报文, 系统会为此耗尽资源。

**避免方法**
1. 第一次握手不马上分配TCB线程管理块，而是等到成功建立连接后再分配TCB。
2. 增大半连接队列
3. 不停监视并释放无效链接

## TCP和UDP的区别
- TCP是面向连接的。在通信之前需要三次握手建立连接，通信之后断开连接时需要四次挥手；UDP不需要进行连接建立。
- TCP是可靠传输服务。通过TCP传输数据可以保证数据无差错、不丢失、不重复；UDP尽最大努力交付，不保证可靠交付。
- 每个TCP对应的是点对点的连接；UDP支持一对一、一对多、多对一、多对多等多种方式的通讯。
- UDP对系统资源要求较少，通讯效率高，实时性好，应用于高速传输并且对实时性有要求的通信；TCP适合需要可靠连接，比如付费、加密数据等等方向都需要依靠TCP。
- TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的；UDP 首部只有 8 个字节，并且是固定不变的。
- TCP 是流式传输，没有边界，但保证顺序和可靠。UDP 是一个包一个包的发送，是有边界的，可能会丢包和乱序。
- TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。
- 应用场景：TCP用于FTP文件传输，HTTP / HTTPS；UDP用于包总量较少的通信，如 DNS、SNMP 等，视频、音频等多媒体通信，广播通信。

## 粘包和拆包问题的解决办法？
TCP的传输方式是面向字节流的，消息会被操作系统拆分成多个tcp报文，那么接收方就不知道这条消息什么时候截止，把后一条消息的内容连到上一条消息的问题就是粘包。

**那么如何处理沾包问题呢？**
沾包问题一般是在应用层解决，也就是你编写程序时考虑如何解析接收到的数据。

粘包的问题出现是因为不知道一个用户消息的边界在哪，如果知道了边界在哪，接收方就可以通过边界来划分出有效的用户消息。

一般有三种方式分包的方式：

- 固定长度的消息；规定一个固定大小，相当于是一个标准。
- 特殊字符作为边界；
- 自定义消息结构。用一个header，里面有个len记录当前数据长度。

## DNS查询服务器的基本流程
先查询本地域名服务器，若没查到则向根域名服务器发送解析请求，根域名服务器返回顶级域名服务器的IP地址，然后向顶级域名服务器发送解析，返回授权域名服务器的IP地址，然后向授权域名服务器发送解析请求，返回结果后保存到本地缓存同时返回给客户机。

## DNS采用TCP还是UDP，为什么？
DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议。

- 区域传输的数据量相比单次DNS查询的数据量要大得多
- 区域传输对数据的可靠性和准确性相比普通的DNS查询要要高得多，因此使用TCP协议

域名解析时一般返回的内容都不超过512字节，首选的通讯协议是UDP。使用UDP传输，不用经过TCP三次握手，这样DNS服务器负载更低，响应更快

## 浏览器输入一个URL到显示器显示的过程？
1. URL解析：先查询浏览器的缓存能否找到对应的IP，如果没有就是上面DNS解析的过程
2. TCP连接：三次握手
3. HTTP请求：HTTP协议是建立在TCP协议之上的应用层协议，其本质按照 HTTP协议标准发送一个索要网页的请求。请求包含请求行、请求头、请求体三个部分组成，有GET、POST等主要方法。
4. 浏览器接收响应：服务器在收到浏览器发送的HTTP请求之后，会将收到的HTTP报文封装成HTTP的Request对象，并通过不同的Web服务器进行处理，处理完的结果以HTTP的Response对象返回，主要包括状态码，响应头，响应报文三个部分。
5. 先解析html文件生成页面结构再用css渲染。
6. 四次挥手断开连接。

## Cookie和Session的关系和区别是什么？
**Cookie**  
cookie是服务器发送到客户端的一小段数据，客户端发送请求的时候带上这段数据服务器将认为这些请求来自同一浏览器，相当于保存了状态

**Session**  
session保存浏览器访问过程中的基本配置和属性，在web页面跳转的过程中，这个配置一直存在，直到会话过期或浏览器关闭。

**区别**
- 存放位置
- 数据大小
- 保存时间
